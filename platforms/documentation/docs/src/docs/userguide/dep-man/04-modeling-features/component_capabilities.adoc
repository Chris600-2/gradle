// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[declaring-component-capabilities]]
= Declaring Capabilities of a Library

Components in a project can offer various features that aren't necessarily tied to the underlying software architecture.
For example, a library might bundle multiple features into a single artifact.
However, when such a library is published, it typically uses a single set of GAV (Group, Artifact, Version) coordinates.
This can result in different "features" of a component being grouped under one set of coordinates.

For example, the link:https://mvnrepository.com/artifact/org.apache.commons/commons-lang3[Apache Commons Lang library] includes a wide range of utility functions for Java, such as string manipulation, number handling, and date utilities.
These features are all bundled under the same GAV coordinates (`org.apache.commons:commons-lang3`), even though they serve different purposes.

Gradle uses the concept of *capabilities* to explicitly declare what features a component provides.

== Declaring capabilities

By defining _capabilities_, Gradleâ€™s dependency management can make smarter decisions, like detecting _incompatible capabilities_ within the dependency graph or prompting you to choose between modules that offer the same _capability_.

Let's say you have two libraries, each providing a logging capability, and you want to ensure that only one of them is used in your project:

- **Library A** (`com.example:library-a:1.0`) provides a logging capability.
- **Library B** (`com.example:library-b:1.0`) also provides a logging capability.

You want to declare these capabilities in your build script to control which library is used:

[source,groovy]
.library-a/build.gradle
----
configurations {
    api {
        // Declaring that this library provides the logging capability
        outgoing.capability('com.example:logging:1.0')
    }
}

dependencies {
    api 'org.slf4j:slf4j-api:1.7.30'
}
----

[source,groovy]
.library-b/build.gradle
----
configurations {
    api {
        // Declaring that this library also provides the logging capability
        outgoing.capability('com.example:logging:1.0')
    }
}

dependencies {
    api 'ch.qos.logback:logback-classic:1.2.3'
}
----

In your consumer project, you want to use only one of these logging capabilities:

[source,kotlin]
.consumer-app/build.gradle
----
dependencies {
    implementation("com.example:library-a:1.0")
    implementation("com.example:library-b:1.0")
}

configurations.all {
    resolutionStrategy {
        // Choose which capability to use
        capabilities {
            select("com.example:logging:1.0").fromCapability("com.example:library-b:1.0")
        }
    }
}
----

The `resolutionStrategy` block tells Gradle to select the logging capability from `library-b`, which means the logging implementation of `library-a` will be excluded.

This way, you can manage conflicting features (capabilities) within your project more effectively, ensuring that the desired implementation is used.

[[sec:declaring-capabilities-external-modules]]
== Declaring capabilities for external modules

It's worth noting that Gradle supports declaring capabilities for components you build, but also for external components in case they didn't.

For example, if your build file contains the following dependencies:

====
include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=dependencies]"]
include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=dependencies]"]
====

As is, it's pretty hard to figure out that you will end up with two logging frameworks on the classpath.
In fact, `zookeeper` will bring in `log4j`, where what we want to use is `log4j-over-slf4j`.
We can preemptively detect the conflict by adding a rule which will declare that both logging frameworks provide the same capability:

====
include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/kotlin",files="build.gradle.kts[tags=declare_capability]"]
include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-declaringCapabilities/groovy",files="build.gradle[tags=declare_capability]"]
====

By adding this rule, we will make sure that Gradle _will_ detect conflicts and properly fail:

[source,text]
----
> Could not resolve all files for configuration ':compileClasspath'.
   > Could not resolve org.slf4j:log4j-over-slf4j:1.7.10.
     Required by:
         project :
      > Module 'org.slf4j:log4j-over-slf4j' has been rejected:
           Cannot select module with conflict on capability 'log4j:log4j:1.7.10' also provided by [log4j:log4j:1.2.16(compile)]
   > Could not resolve log4j:log4j:1.2.16.
     Required by:
         project : > org.apache.zookeeper:zookeeper:3.4.9
      > Module 'log4j:log4j' has been rejected:
           Cannot select module with conflict on capability 'log4j:log4j:1.2.16' also provided by [org.slf4j:log4j-over-slf4j:1.7.10(compile)]
----

Refer to the <<dependency_capability_conflict.adoc#sub:selecting-between-candidates, capabilities documentation>> to learn how to resolve capability conflicts.

[[sec:declaring-additional-capabilities-for-a-local-component]]
== Declaring capabilities for local components

By default, all components have an _implicit capability_ tied to their GAV (Group, Artifact, Version) coordinates.
However, you can also declare additional _explicit capabilities_ for a component.
This is particularly useful when a library published under different GAV coordinates serves as an _alternative implementation_ of the same API:

====
include::sample[dir="snippets/dependencyManagement/modelingFeatures-outgoingCapabilities/kotlin",files="build.gradle.kts[tags=declare-outgoing-capabilities]"]
include::sample[dir="snippets/dependencyManagement/modelingFeatures-outgoingCapabilities/groovy",files="build.gradle[tags=declare-outgoing-capabilities]"]
====

Capabilities must be attached to _outgoing configurations_, which are <<declaring_dependencies_adv.adoc#sec:resolvable-consumable-configs,consumable configurations>> of a component.

This example shows that we declare two capabilities:

1. `com.acme:my-library:1.0`, representing the component's _implicit capability_.
2. `com.other:module:1.1`, representing an additional capability of the library.

It's important to note that once you start declaring _explicit_ capabilities, you must declare _all_ capabilities, including the _implicit_ one.

The second capability could be specific to this library or match a capability provided by an external component.
If `com.other:module` exists in the same dependency graph, the build will fail, and consumers will <<dependency_capability_conflict.adoc#sub:selecting-between-candidates, need to choose which module to use>>.

Capabilities are published to Gradle Module Metadata but have _no equivalent_ in POM or Ivy metadata files.
As a result, when publishing such a component, Gradle will warn you that this feature is only supported for Gradle consumers:

[source,text]
----
Maven publication 'maven' contains dependencies that cannot be represented in a published pom file.
  - Declares capability com.acme:my-library:1.0
  - Declares capability com.other:module:1.1
----
