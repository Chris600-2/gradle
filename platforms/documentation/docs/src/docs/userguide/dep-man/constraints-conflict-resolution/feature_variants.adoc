// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

:maven-optional-deps: https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html[Maven optional dependencies]
:metadata-file-spec: https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md

[[feature_variants]]
= Creating Features

Gradle supports modeling *features* to handle scenarios where a single library can be divided into multiple related but distinct libraries, each providing additional functionality.

This allows for a number of different scenarios (list is non-exhaustive):

- a (better) substitute for {maven-optional-deps}
- a _main_ library is built with support for different mutually-exclusive implementations of runtime features; the <<sec::incompatible_variants,user must choose one, and only one, implementation of each such feature>>
- a _main_ library is built with support for optional runtime features, each of which requires a different set of dependencies
- a _main_ library comes with supplementary features like _test fixtures_
- a _main_ library comes with a main artifact, and enabling an additional feature requires additional artifacts

== Understanding features variants

*Feature Variants* in Gradle allow developers to split a single component into multiple related features that can be optionally selected by consumers.
This is especially useful when different parts of a library or project offer additional functionalities that not every consumer may need.
By using feature variants, developers can manage optional dependencies, alternative implementations, or supplementary tools in a structured and modular way.

1. **Separation of Features**: Each feature is defined as its own source set, making it possible to isolate functionality such as JSON or XML serialization from the main project.
2. **Optional Features**: Consumers can choose which feature(s) they need, reducing unnecessary dependencies and code in their projects.
3. **Variant-Aware Dependency Management**: Gradle uses variant-aware dependency management to ensure that the correct version of a library or feature is selected based on the consumer's needs and the capabilities of the features.

Consider a project that has a core *data model* component.
The project also provides two optional features: *JSON serialization* and *XML serialization*.
Each feature is implemented separately and can be selected by the consumer depending on their serialization requirements.

1. **Create Source Sets**:
You create a separate source set for each feature (e.g., `json` and `xml`).

[source,kotlin]
.library/build.gradle.kts
----
val json = sourceSets.create("json")
val xml = sourceSets.create("xml")
----

2. **Register Feature Variants**:
Each feature source set is registered as a feature variant, making it consumable by other projects.

[source,kotlin]
.library/build.gradle.kts
----
java.registerFeature("json") {
    usingSourceSet(json)
}
java.registerFeature("xml") {
    usingSourceSet(xml)
}
----

3. **Define Dependencies**:
Each feature variant has its own dependencies, such as libraries for handling JSON or XML, and it also depends on the main data model.

[source,kotlin]
.library/build.gradle.kts
----
dependencies {
    jsonImplementation("com.fasterxml.jackson.core:jackson-databind:2.13.0")
    xmlImplementation("org.apache.xml:serializer:2.7.2")
}
----

4. **Capabilities and Variant Selection**:
When consumers choose to use one feature (e.g., JSON), Gradle ensures that only one of the mutually exclusive features (JSON or XML) is included, avoiding conflicts.

[source,kotlin]
.app/build.gradle.kts
----
dependencies {
    implementation("com.example:library") {
        capabilities {
            requireCapability("com.example.library.json")
        }
    }
}
----

[[sec::feature_variant_selection]]
== Selecting features via capabilities

Declaring a dependency on a component is typically done using a set of coordinates (group, artifact, version—known as GAV coordinates).
These coordinates allow Gradle to determine the component you want, but the component may offer different **variants**.
A variant is chosen based on how the component is used.
For example:

- When compiling against a component, you need the API of the component.
- When running code, you need the runtime of the component.

Each variant of a component also provides <<dependency_capability_conflict.adoc#sub:capabilities,**capabilities**>>, a feature or functionality that the variant offers.
Capabilities are denoted using GAV coordinates but describe what the component can provide.
For example:

- "I provide an SLF4J binding"
- "I provide runtime support for MySQL"
- "I provide a Groovy runtime"

In general, having two components that provide the same capability in a dependency graph creates a conflict.

In summary:

1. **Variants provide capabilities** corresponding to the GAV coordinates of the component.
2. **No two variants** in a dependency graph can provide the same capability.
3. **Multiple variants** of a component can be selected as long as they provide **different capabilities**.

Most Java libraries provide variants for `api` and `runtime`, which share the same default capability.
This means you **cannot** have both the API and runtime variants of the same component in a dependency graph at the same time.

However, some components offer additional features, such as **test fixtures**, that provide different capabilities.
In this case, you **can** have both the `runtime` and `test fixtures runtime` variants, because they declare different capabilities.

Let's look at an example where a consumer might need two variants from a component:

1. The **main** feature (library runtime).
2. The **test fixtures** feature (runtime for testing).

Here’s how you would declare these dependencies:

[source,kotlin]
----
dependencies {
    // Depend on the main runtime variant
    implementation("com.example:my-library:1.0")

    // Require the 'test fixtures' capability
    testImplementation("com.example:my-library:1.0") {
        capabilities {
            requireCapability("com.example.my-library.test-fixtures")
        }
    }
}
----

- The `implementation` configuration selects the default `runtime` variant.
- The `testImplementation` configuration requires the `test-fixtures` capability, allowing both to coexist in the same dependency graph.

NOTE: While Gradle’s resolution engine supports multi-variant components independently of the ecosystem, **features** (like test fixtures) are only available using Java plugins.

[[sec::declare_feature_variants]]
== Registering features

Features can be declared by applying the `java-library` plugin.

The following code illustrates how to declare a feature named `mongodbSupport`:

====
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=register_variant,register_variant2]"]
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=register_variant,register_variant2]"]
====

Gradle will automatically set up a number of things for you, similar to how the <<java_library_plugin#java_library_plugin,Java Library Plugin>> sets up configurations.

Dependency scope configurations are created in the same manner as for the main feature (i.e. each feature can have its own set of configurations):

- the configuration `mongodbSupportApi`, used to _declare API dependencies_ for this feature
- the configuration `mongodbSupportImplementation`, used to _declare implementation dependencies_ for this feature
- the configuration `mongodbSupportRuntimeOnly`, used to _declare runtime-only dependencies_ for this feature
- the configuration `mongodbSupportCompileOnly`, used to _declare compile-only dependencies_ for this feature
- the configuration `mongodbSupportCompileOnlyApi`, used to _declare compile-only API dependencies_ for this feature

Furthermore, consumable configurations are created in the same manner as for the main feature (i.e. each feature can have its own set of configurations):

- the configuration `mongodbSupportApiElements`, used by consumers to fetch the artifacts and API dependencies of this feature
- the configuration `mongodbSupportRuntimeElements`, used by consumers to fetch the artifacts and runtime dependencies of this feature

A feature should have a _source set_ with the same name.

Gradle will create a `Jar` task to bundle the classes built from the feature source set, using a classifier corresponding to the kebab-case name of the feature.

WARNING: Do not use the _main_ source set when registering a feature. This behavior will be deprecated in a future version of Gradle.

To declare the specific dependencies of this feature:

====
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=variant_dependencies]"]
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=variant_dependencies]"]
====

--
By convention, Gradle maps the feature name to a capability whose group and version are the same as the group and version of the main component, respectively, but whose name is the main component name followed by a `-` followed by the kebab-cased feature name.

For example, if:

- the component's group is `org.gradle.demo`
- the name is `provider`
- the version is `1.0`
- the feature is named `mongodbSupport`

Then, the feature's variants will have the `org.gradle.demo:provider-mongodb-support:1.0` capability.

If you define custom capability names or assign additional capabilities to a variant, it's advisable to maintain the same naming convention.
--

[[sec::publishing_feature_variants]]
== Publishing features

--
Depending on the metadata file format, publishing features may be lossy:

- using {metadata-file-spec}[Gradle Module Metadata], everything is published and consumers will get the full benefit of features
- using POM metadata (Maven), features are published as **optional dependencies** and artifacts of features are published with different _classifiers_
- using Ivy metadata, features are published as extra configurations, which are _not_ extended by the `default` configuration
--

Publishing features is supported using the `maven-publish` and `ivy-publish` plugins only.
The Java Library Plugin will take care of registering the additional variants for you, so there's no additional configuration required, only the regular publications:

====
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=plugins,publishing]"]
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=plugins,publishing]"]
====

[[sub:javadoc_sources_features_variants]]
=== Adding javadoc and sources JARs

Similar to the <<building_java_projects.adoc#sec:java_packaging,main Javadoc and sources JARs>>, you can configure the added feature so that it produces JARs for the Javadoc and sources:

====
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/kotlin",files="build.gradle.kts[tags=register_variant_extra_jars]"]
include::sample[dir="snippets/java-feature-variant/producer-separate-sourceset/groovy",files="build.gradle[tags=register_variant_extra_jars]"]
====

[[sec::consuming_feature_variants]]
== Depending on features

--
As mentioned earlier, features can be lossy when published.
As a consequence, a consumer can depend on a feature only in these cases:

- with a project dependency (in a multi-project build)
- with Gradle Module Metadata available, that is the publisher MUST have published it
- within the Ivy world, by declaring a dependency on the configuration matching the feature
--

A consumer can specify that it needs a specific feature of a producer by declaring required capabilities.
For example, if a producer declares a "MySQL support" feature like this:

====
include::sample[dir="snippets/java-feature-variant/requiring-features/kotlin/producer",files="build.gradle.kts[tags=producer]"]
include::sample[dir="snippets/java-feature-variant/requiring-features/groovy/producer",files="build.gradle[tags=producer]"]
====

Then the consumer can declare a dependency on the MySQL support feature by doing this:

====
include::sample[dir="snippets/java-feature-variant/requiring-features/kotlin/consumer",files="build.gradle.kts[tags=consumer]"]
include::sample[dir="snippets/java-feature-variant/requiring-features/groovy/consumer",files="build.gradle[tags=consumer]"]
====

This will automatically bring the `mysql-connector-java` dependency on the runtime classpath.
If there were more than one dependency, all of them would be brought, meaning that a feature can be used to group dependencies which contribute to a feature together.

Similarly, if an external library with features was published with {metadata-file-spec}[Gradle Module Metadata], it is possible to depend on a feature provided by that library:

====
include::sample[dir="snippets/java-feature-variant/requiring-features-external/kotlin/project",files="build.gradle.kts[tags=consumer]"]
include::sample[dir="snippets/java-feature-variant/requiring-features-external/groovy/project",files="build.gradle[tags=consumer]"]
====

[[sec::incompatible_variants]]
== Handling mutually exclusive variants

The main advantage of using _capabilities_ as a way to handle features is that you can precisely handle compatibility of variants.
The rule is simple:

> No two variants in a dependency graph can provide the same capability

We can leverage this to ensure that Gradle fails whenever the user mis-configures dependencies.
Consider a situation where your library supports MySQL, Postgres and MongoDB, but that it's only allowed to choose _one_ of those at the same time.
We can model this restriction by ensuring each feature also provides the same capability, thus making it impossible for these features to be used together in the same graph.

====
include::sample[dir="snippets/java-feature-variant/incompatible-variants/kotlin/producer",files="build.gradle.kts[tags=producer]"]
include::sample[dir="snippets/java-feature-variant/incompatible-variants/groovy/producer",files="build.gradle[tags=producer]"]
====

Here, the producer declares 3 features, one for each database runtime support:

- `mysql-support` provides both the `db-support` and `mysql-support` capabilities
- `postgres-support` provides both the `db-support` and `postgres-support` capabilities
- `mongo-support` provides both the `db-support` and `mongo-support` capabilities

Then if the consumer tries to get both the `postgres-support` and `mysql-support` features (this also works transitively):

====
include::sample[dir="snippets/java-feature-variant/incompatible-variants/kotlin/consumer",files="build.gradle.kts[tags=consumer]"]
include::sample[dir="snippets/java-feature-variant/incompatible-variants/groovy/consumer",files="build.gradle[tags=consumer]"]
====

Dependency resolution would fail with the following error:

----
Cannot choose between
   org.gradle.demo:producer:1.0 variant mysqlSupportRuntimeElements and
   org.gradle.demo:producer:1.0 variant postgresSupportRuntimeElements
   because they provide the same capability: org.gradle.demo:producer-db-support:1.0
----
