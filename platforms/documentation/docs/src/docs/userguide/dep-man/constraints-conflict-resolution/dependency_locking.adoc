// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[dependency-locking]]
= Locking Versions

Using dynamic dependency versions (e.g., `1.+` or `[1.0,2.0)`) can make builds non-deterministic, causing them to break unexpectedly, sometimes due to a transitive dependency outside the build author's control.

To ensure https://reproducible-builds.org/[reproducible builds], it's necessary to *lock* versions of dependencies and their transitive dependencies.
This guarantees that a build with the same inputs will always resolve to the same module versions, a process known as *dependency locking*.

Dependency locking is crucial for several scenarios:

- **Managing Multiple Repositories:** Companies managing multiple repositories can avoid relying on `-SNAPSHOT` or changing dependencies, which can cause cascading failures when a dependency introduces a bug or incompatibility.

- **Using the Latest Dependencies:** Teams that use dynamic versions can lock their dependencies only for releases. The release tag will include the locked states, ensuring the build remains fully reproducible when bug fixes need to be developed.

- **Publishing Resolved Versions:** Combined with <<publishing_maven.adoc#publishing_maven:resolved_dependencies,publishing resolved versions>>, dependency locking allows replacing the declared dynamic versions at publication time. Consumers will then see the resolved versions that your release used.

Locking is enabled per <<dependency_configurations.adoc#sec:what-are-dependency-configurations,dependency configuration>>.
Once enabled, you must create an initial lock state, causing Gradle to verify that resolution results do not change.
This ensures the same dependencies are selected, even if newer versions are available.
If your build changes in a way that impacts the resolved set of dependencies, it will fail, ensuring that changes in published dependencies or build definitions do not alter resolution without updating the lock state.

[NOTE]
====
Dependency locking is effective with <<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic versions>> but has no impact on <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing versions>> (e.g., `-SNAPSHOT`), where the coordinates remain the same, but the content may change. Gradle will emit a warning when persisting the lock state if changing dependencies are present in the resolution result.
====

== Locking specific configurations

Locking of a configuration happens through the link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html[ResolutionStrategy] API:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=locking-single]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=locking-single]"]
====

Only configurations that can be resolved will have lock state attached to them.
Applying locking on non resolvable-configurations is a no-op.

== Locking all configurations

The following locks all configurations:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/kotlin",files="build.gradle.kts[tags=locking-all]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/groovy",files="build.gradle[tags=locking-all]"]
====

NOTE: The above will lock all _project_ configurations, but not the _buildscript_ ones.

== Disable locking specific configurations

You can also disable locking on a specific configuration.
This can be useful if a plugin configured locking on all configurations, but you happen to add one that should not be locked:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-unlockingSingleConfiguration/kotlin",files="build.gradle.kts[tags=locking-one]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-unlockingSingleConfiguration/groovy",files="build.gradle[tags=locking-one]"]
====

== Locking buildscript classpath configuration

If you apply plugins to your build, you may want to leverage dependency locking there as well.
To lock the <<plugins.adoc#sec:applying_plugins_buildscript,`classpath` configuration>> used for script plugins:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingClasspathConfiguration/kotlin",files="build.gradle.kts[tags=locking-classpath]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingClasspathConfiguration/groovy",files="build.gradle[tags=locking-classpath]"]
====

== Generating and updating dependency locks

To generate or update the lock state, use the `--write-locks` command line argument along with the tasks that would trigger configurations to be resolved.
This will create or update the lock state for each resolved configuration during that build execution.
If a lock state already exists, it will be overwritten.

NOTE: Gradle won't write the lock state to disk if the build fails, preventing the persistence of potentially invalid states.

[[lock_all_configurations_in_one_build_execution]]
=== Lock all configurations in a single build execution

When working with multiple configurations, you may want to lock them all at once in a single build execution.
You have two options for this:

1. **Run `gradle dependencies --write-locks`:**
- This command will lock all resolvable configurations that have locking enabled.
- In a multi-project setup, note that `dependencies` is executed only on one project, typically the root project.

2. **Declare a Custom Task to Resolve All Configurations:**
- This approach is particularly useful if you need more control over which configurations are locked.
- It is not applicable to Android projects.

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/kotlin",files="build.gradle.kts[tags=resolve-all]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingAllConfigurations/groovy",files="build.gradle[tags=resolve-all]"]
====

This custom task resolves all configurations, locking them in the process.
It's especially useful in environments like native builds, where not all configurations can be resolved on a single platform.
By filtering and resolving specific configurations, you ensure that only the relevant ones are locked, tailoring the locking process to your project's needs.

== Understanding lock state location and format

A lockfile is a critical component that stores the exact versions of dependencies used in a project, ensuring consistent builds across different environments and over time. It prevents unexpected changes in dependencies when a project is built on different machines or at different times.

=== Location of lock files

- The lock state is preserved in a file named `gradle.lockfile`, located at the root of each project or subproject directory.
- The exception is the lockfile for the <<plugins.adoc#sec:applying_plugins_buildscript,buildscript itself>>, which is named `buildscript-gradle.lockfile`.

=== Structure of lock files

Consider the following dependency declaration:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=locking-explicit]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=locking-explicit]"]
====

With the above configuration, the generated `gradle.lockfile` will look like this:

[listing]
.gradle.lockfile
----
include::{snippetsPath}/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy/gradle.lockfile[]
----

Where:

- **Each line** represents a single dependency in the `group:artifact:version` format.
- **Configurations:** After the version, the configurations that include the dependency are listed.
- **Ordering:** Dependencies and configurations are listed alphabetically to make version control diffs easier to manage.
- **Empty Configurations:** The last line lists configurations that are empty, meaning they contain no dependencies.

This lockfile should be included in source control to ensure that all team members and environments use the exact same dependency versions.

[[migrate_single_lockfile]]
== Migrating your legacy lockfile

If your project uses the legacy lock file format of a file per locked configuration, follow these instructions to migrate to the new format:

1. Follow the documentation for <<#lock_all_configurations_in_one_build_execution, writing>> or <<#selectively_updating_lock_state_entries, updating>> dependency lock state.
2. Upon writing the single lock file per project, Gradle will also delete all lock files per configuration for which the state was transferred.

NOTE: Migration can be done one configuration at a time. Gradle will keep sourcing the lock state from the per configuration files as long as there is no information for that configuration in the single lock file.

[[configuring_the_per_project_lock_file_name_and_location]]
== Configuring the lock file name and location

When using a single lock file per project, you can configure its name and location.

This capability allows you to specify a file name based on project properties, enabling a single project to store different lock states for different execution contexts.

For example, in the JVM ecosystem, the Scala version is often included in artifact coordinates:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=locking-file-name]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=locking-file-name]"]
====

== Running a build with lock state present

The moment a build needs to resolve a configuration that has locking enabled and it finds a matching lock state,
it will use it to verify that the given configuration still resolves the same versions.

A successful build indicates that the same dependencies are used as stored in the lock state, regardless if new versions matching the dynamic selector have been produced.

The complete validation is as follows:

* Existing entries in the lock state must be matched in the build
** A version mismatch or missing resolved module causes a build failure
* Resolution result must not contain extra dependencies compared to the lock state

[[fine_tuning_dependency_locking_behaviour_with_lock_mode]]
=== Fine-tuning dependency locking behaviour with lock mode

While the default lock mode behaves as described above, two other modes are available:

Strict mode::
In this mode, in addition to the validations above, dependency locking will fail if a configuration marked as _locked_ does not have lock state associated with it.

Lenient mode::
In this mode, dependency locking will still pin dynamic versions but otherwise changes to the dependency resolution are no longer errors.

The lock mode can be controlled from the `dependencyLocking` block as shown below:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockModeSelection/kotlin",files="build.gradle.kts[tags=lock-mode]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockModeSelection/groovy",files="build.gradle[tags=lock-mode]"]
====

[[selectively_updating_lock_state_entries]]
== Updating lock state entries selectively

In order to update only specific modules of a configuration, you can use the `--update-locks` command line flag.
It takes a comma (`,`) separated list of module notations.
In this mode, the existing lock state is still used as input to resolution, filtering out the modules targeted by the update.

----
$ ./gradlew dependencies --update-locks org.apache.commons:commons-lang3,org.slf4j:slf4j-api
----

Wildcards, indicated with `*`, can be used in the group or module name. They can be the only character or appear at the end of the group or module respectively.
The following wildcard notation examples are valid:

* `org.apache.commons:*`: will let all modules belonging to group `org.apache.commons` update
* `*:guava`: will let all modules named `guava`, whatever their group, update
* `org.springframework.spring*:spring*`: will let all modules having their group starting with `org.springframework.spring` and name starting with `spring` update

NOTE: The resolution may cause other module versions to update, as dictated by the Gradle resolution rules.

== Disabling dependency locking

To disable dependency locking for a configuration:

1. **Remove Locking Configuration:**
Ensure that the configuration you no longer want to lock is not configured with dependency locking. This means removing or commenting out any `activateDependencyLocking()` calls for that configuration.

2. **Update Lock State:**
The next time you update and save the lock state (using the `--write-locks` option), Gradle will automatically clean up any stale lock state associated with the configurations that are no longer locked.

NOTE: Gradle must resolve a configuration that is no longer marked as locked to detect and drop the associated lock state. Without resolving the configuration, Gradle cannot identify which lock state should be cleaned up.

[[ignoring_dependencies]]
== Ignoring specific dependencies from the lock state

In some scenarios, dependency locking may not be focused on reproducibility.

As a build author, you might want certain dependencies to update more frequently than others.
For example, internal dependencies within an organization might always use the latest version, while third-party dependencies follow a different update cycle.

CAUTION: This approach can compromise reproducibility. Consider using <<#fine_tuning_dependency_locking_behaviour_with_lock_mode,different lock modes>> or <<#configuring_the_per_project_lock_file_name_and_location,separate lock files>> for specific cases.

You can configure dependencies to be ignored in the `dependencyLocking` project extension:

====
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/kotlin",files="build.gradle.kts[tags=ignore-dependencies]"]
include::sample[dir="snippets/dependencyManagement/dependencyLocking-lockingSingleFilePerProject/groovy",files="build.gradle[tags=ignore-dependencies]"]
====

The notation `<group>:<name>` is used to specify dependencies, where `\*` acts as a trailing wildcard. Note that `*:*` is not accepted, as it effectively disables locking.
See <<#selectively_updating_lock_state_entries,the description>> on updating lock files for more details.

Ignoring dependencies will have the following effects:

- Ignored dependencies apply across all locked configurations, and the setting is project-wide.
- Ignoring a dependency does not exclude its transitive dependencies from the lock state.
- No validation ensures that an ignored dependency is present in any configuration resolution.
- If the dependency is present in the lock state, it will be filtered out when loading.
- If the dependency is present in the resolution result, it will be ignored when validating the resolution against the lock state.
- When the lock state is updated and persisted, any ignored dependency will be omitted from the written lock state.

[[locking_limitations]]
== Understanding locking limitations

- Dependency locking does not currently apply to source dependencies.
