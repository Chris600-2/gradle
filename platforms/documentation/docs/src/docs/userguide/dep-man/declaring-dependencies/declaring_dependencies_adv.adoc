// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[declaring-dependencies-basics]]
= Declaring Dependencies Basics

[[sec:dependency-types]]
== Types of dependencies

There are three types of dependencies in Gradle:

1. *Module Dependencies*: Refer to libraries from external repositories.
2. *Project Dependencies*: Refer to other projects in the same multi-project build.
3. *File Dependencies*: Refer to local files or directories, such as `.jar` or `.aar` files.

[[sub:module_dependencies]]
=== 1. Module dependencies

Module dependencies are the most common dependencies.
They refer to a module in a repository:

====
include::sample[dir="snippets/artifacts/externalDependencies/kotlin",files="build.gradle.kts[tags=module-dependencies]"]
include::sample[dir="snippets/artifacts/externalDependencies/groovy",files="build.gradle[tags=module-dependencies]"]
====

Gradle offers multiple notations for declaring module dependencies, including string notation and map notation.

- **String Notation:** Simplifies dependency declaration by combining the group, name, and version into a single string.
- **Map Notation:** Allows for a more detailed specification, enabling the definition of all properties.

For advanced configurations, such as making a dependency transitive, you can use closures alongside these notations.

Refer to the link:{groovyDslPath}/org.gradle.api.artifacts.dsl.DependencyHandler.html[`DependencyHandler`] class in the API documentation for more examples and details.
Additionally, explore the link:{javadocPath}/org/gradle/api/artifacts/ExternalModuleDependency.html[`ExternalModuleDependency`] class to understand the full range of properties and configuration methods available.

[[sub:project_dependencies]]
=== 2. Project dependencies

Project dependencies allow you to reference other projects or subprojects within a multi-project Gradle build.

image::dependency-management-project-dependencies.png[]

This is useful for organizing large projects into smaller, modular components:

====
include::sample[dir="snippets/dependencyManagement/declaringDependencies-projectDependencies/kotlin",files="web-service/build.gradle.kts[tags=project-dependencies]"]
include::sample[dir="snippets/dependencyManagement/declaringDependencies-projectDependencies/groovy",files="web-service/build.gradle[tags=project-dependencies]"]
====

Gradle uses the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:project(java.lang.String)[`project()`] function to define a project dependency.
This function takes the path to the target project within the build.
The path is typically defined using a colon (`:`) to separate different levels of the project hierarchy.

Project dependencies are automatically included in the correct build order, ensuring that the dependent project is built before the project that depends on it.

Refer to the link:{groovyDslPath}/org.gradle.api.artifacts.dsl.DependencyHandler.html[`DependencyHandler`] class in the API documentation for more examples and details on how to configure project dependencies within a multi-project build.

[[sub:file_dependencies]]
=== 3. File dependencies

File dependencies are used when a project relies on external libraries that are not hosted in a binary repository (e.g., JFrog Artifactory or Sonatype Nexus).
Instead, these dependencies might be stored on a shared drive or checked into version control alongside the project source code.

image::dependency-management-file-dependencies.png[]

File dependencies are unique because they represent a direct reference to files on the filesystem without any associated <<glossary.adoc#sub:terminology_module_metadata,metadata>>, such as transitive dependencies, origin, or author information.

====
include::sample[dir="snippets/dependencyManagement/declaringDependencies-fileDependencies/kotlin",files="build.gradle.kts[tags=file-dependencies]"]
include::sample[dir="snippets/dependencyManagement/declaringDependencies-fileDependencies/groovy",files="build.gradle[tags=file-dependencies]"]
====

In this example, each dependency explicitly specifies its location within the file system.
Common methods for referencing these files include:

- link:link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object++[]++)[`Project.files()`]: Accepts one or more file paths directly.
- link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object++...++-[`ProjectLayout.files()`]: Accepts one or more file paths directly.
- link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)[`Project.fileTree()`]: Defines a directory and includes or excludes specific file patterns.

[NOTE]
====
The order of files in a `FileTree` is not guaranteed to be stable, even on the same computer.
As a result, dependency configurations using `FileTree` may produce resolution results with varying order, which can impact the cacheability of tasks that use these results as inputs.
To ensure more predictable and stable behavior, it is recommended to use the simpler `files` method where possible.
====

Alternatively, you can use a <<declaring_repositories_adv.adoc#sub:flat_dir_resolver,flat directory>> repository to specify the source directory for multiple file dependencies.

For more details on working with file dependencies, refer to the link:{groovyDslPath}/org.gradle.api.artifacts.dsl.DependencyHandler.html[`DependencyHandler`] and `ProjectLayout` classes in the Gradle API documentation.

File dependencies also allow you to add a set of files directly to a configuration without using a repository.
This is useful if you either cannot or choose not to store files in a repository, or if you want to avoid using repositories altogether.

To add files as dependencies, pass a <<working_with_files.adoc#sec:file_collections,file collection>> to the configuration:

====
include::sample[dir="snippets/artifacts/externalDependencies/kotlin",files="build.gradle.kts[tags=file-dependencies]"]
include::sample[dir="snippets/artifacts/externalDependencies/groovy",files="build.gradle[tags=file-dependencies]"]
====

Note that file dependencies are not included in the published dependency descriptor for your project.
However, they are available in transitive dependencies within the same build, meaning they can be used within the current build but not outside it.

You can specify which tasks produce the files for a file dependency.
This is useful when files are generated during the build process:

====
include::sample[dir="snippets/artifacts/generatedFileDependencies/kotlin",files="build.gradle.kts[tags=generated-file-dependencies]"]
include::sample[dir="snippets/artifacts/generatedFileDependencies/groovy",files="build.gradle[tags=generated-file-dependencies]"]
====

----
$ gradle -q list
include::{snippetsPath}/artifacts/generatedFileDependencies/tests/generatedFileDependencies.out[]
----

[[sec:documenting-dependencies]]
== Documenting dependencies

When declaring a dependency or a <<dependency_constraints.adoc#sec:adding-constraints-transitive-deps,dependency constraint>>, you can provide a custom reason to clarify why the dependency is included.
This helps make your build script and the <<viewing_debugging_dependencies.adoc#sec:identifying_reason_dependency_selection,dependency insight report>> easier to interpret.

====
include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependencyReason/kotlin",files="build.gradle.kts[tags=dependency-reason]"]
include::sample[dir="snippets/dependencyManagement/inspectingDependencies-dependencyReason/groovy",files="build.gradle[tags=dependency-reason]"]
====

In this example, the link:{javadocPath}/org/gradle/api/artifacts/DependencyConstraint.html#because(java.lang.String)[`because()`] method provides a reason for including the `asm` library, which helps explain its purpose in the context of the build.

----
> gradle -q dependencyInsight --dependency asm
include::{snippetsPath}/dependencyManagement/inspectingDependencies-dependencyReason/tests/dependencyReasonReport.out[]
----
