// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[understanding_dependency_resolution]]
= 6. Dependency Resolution

// TO DO INTRODUCE CAPABILITIES

Dependency resolution in Gradle involves two main steps:

1. **Graph Resolution**
2. **Artifact Resolution**

== 1. Graph Resolution

*Graph resolution* is the process of determining the full set of transitive dependencies, and their versions, that are required for a given set of declared dependencies.

Graph resolution operates solely on dependency metadata (GMM, POMs).
In this phase, artifacts (JARs) are not resolved.
Only the structure of the graph, based on the relationship between dependencies, are calculated at this time.

=== 1. Discovering dependencies

Graph resolution begins with the *project* and external (*module*) dependencies declared in the build script.

- A *module* is a discrete unit of software that can be built and published, such as link:https://mvnrepository.com/artifact/com.google.guava/guava[`com.google.guava:guava`].
- Each version of a *module* is referred to as a *component*, such as link:https://mvnrepository.com/artifact/com.google.guava/guava/33.3.0-jre[`com.google.guava:guava:33.3.0-jre`].

A *project* contributes a single component to the dependency graph, which itself belongs to a module.

In the example below, the *component* `com.google.guava:guava:33.0.0-jre` is added as a dependency to the `implementation` *configuration* in a Java application:

[source,kotlin]
.build.gradle.kts
----
dependencies {
    implementation("com.google.guava:guava:33.0.0-jre")
}
----

=== 2. Perform conflict resolution

Gradle identifies and resolves any version conflicts when multiple declared or transitive dependencies request different *versions* of the same *module*.

Even though a user might declare version `33.0.0-jre` of a *module*, this may not be the version ultimately resolved in the graph.
Gradle’s conflict resolution strategy, which defaults to selecting the highest version, selects a single version of a module when multiple are requested.

However, Gradle APIs can be used to change the outcome:

- **Resolution Rules**: Gradle allows configuring rules to enforce specific versions, reject certain versions, or substitute dependencies as needed.
- **Dependency Substitution**: Rules defined in build logic can replace one dependency with another, alter versions, or redirect requests for one module with another.
- **Dynamic Versions**: If dependencies are defined with dynamic versions (e.g., `1.0.+`) or version ranges (e.g., `[1.0, 2.0)`), Gradle resolves these to specific versions by querying the repositories.
- **Dependency Locking**: If enabled, Gradle checks lock files to ensure consistent versions across build invocations, preventing unexpected changes in dependency versions.

In the example, Gradle selects the *component* `com.google.guava:guava:33.0.0-jre` (the `33.0.0-jre` version of the `com.google.guava:guava` *module*).

=== 3. Retrieve the metadata

// TO DO - use https://repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.17.2/jackson-databind-2.17.2.module

Once Gradle has determined which version of an external *module* to resolve, it fetches the *metadata* for the *component* from an `ivy`, `module` (GMM), or link:https://repo1.maven.org/maven2/com/google/guava/guava/33.0.0-jre/guava-33.0.0-jre.pom[`pom`] metadata file in the repository.

Here’s a snapshot of the *metadata* for `com.google.guava:guava:33.0.0-jre`:

[source,xml]
----
<variant name="jreApiElements">
    <artifact>guava-33.0.0-jre.jar</artifact>
    <transitiveDependencies count="6">
        <dependency>com.google.guava:failureaccess:1.0.1</dependency>
        <dependency>com.google.guava:listenablefuture:9999.0</dependency>
        <dependency>com.google.code.findbugs:jsr305:3.0.2</dependency>
        <dependency>org.checkerframework:checker-qual:3.12.0</dependency>
        <dependency>com.google.errorprone:error_prone_annotations:2.26.1</dependency>
        <dependency>com.google.j2objc:j2objc-annotations:2.8</dependency>
    </transitiveDependencies>
</variant>
<variant name="jreRuntimeElements">
    <artifact>guava-33.0.0-jre.jar</artifact>
    <transitiveDependencies count="5">
        <dependency>com.google.guava:failureaccess:1.0.1</dependency>
        <dependency>com.google.guava:listenablefuture:9999.0</dependency>
        <dependency>com.google.code.findbugs:jsr305:3.0.2</dependency>
        <dependency>org.checkerframework:checker-qual:3.12.0</dependency>
        <dependency>com.google.errorprone:error_prone_annotations:2.26.1</dependency>
    </transitiveDependencies>
</variant>
----

As you can see, the `com.google.guava:guava:33.0.0-jre` *component* offers two *variants*:

- The `jreApiElements` *variant* includes dependencies required for compiling projects against Guava.
- The `jreRuntimeElements` *variant* includes dependencies required for executing Guava during runtime.

A *variant* is a specific variation of a *component* tailored for a particular use case or environment.
*Variants* allow you to provide different definitions of your *component* depending on the context in which it’s used.

Each *variant* consists of a set of *artifacts* and defines a set of *dependencies*.
The `jreApiElements` variant provides the `guava-33.0.0-jre.jar` artifact, which will be downloaded later in the *Artifact Resolution* phase.

=== 4. Update the graph

Gradle builds a dependency graph that represents a configuration's dependencies and their relationships.
This graph includes both direct dependencies (explicitly declared in the build script) and transitive dependencies (dependencies of the direct dependencies and other transitive dependencies).

The dependency graph is made up of _nodes_ where:

- Each _node_ represents a *variant*.
- Each *dependency* selects a *variant* from a *component*.

These _nodes_ are connected by edges, representing the dependencies between *variants*.
The edges indicate how one variant relies on another.

For instance, if your project depends on Guava, and Guava depends on `jsr305`, the edge in the graph represents that `jsr305` is a dependency of one of Guava's variants.

The `dependencies` task can be used to visualize the structure of a dependency graph:

[source,text]
----
$ ./gradlew app:dependencies

[...]

compileClasspath - Compile classpath for source set 'main'.
\--- com.google.guava:guava:33.0.0-jre
     +--- com.google.guava:failureaccess:1.0.2
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.41.0
     +--- com.google.errorprone:error_prone_annotations:2.23.0
     \--- com.google.j2objc:j2objc-annotations:2.8

runtimeClasspath - Runtime classpath of source set 'main'.
\--- com.google.guava:guava:33.0.0-jre
     +--- com.google.guava:failureaccess:1.0.2
     +--- com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
     +--- com.google.code.findbugs:jsr305:3.0.2
     +--- org.checkerframework:checker-qual:3.41.0
     \--- com.google.errorprone:error_prone_annotations:2.23.0

----

In this output, `compileClasspath` and `runtimeClasspath` represent specific resolvable configurations in the project.
Each resolvable configuration calculates a separate dependency graph.
Notice how different configurations can resolve to a different set of transitive dependencies for the same set of declared dependencies.
Each *variant* is owned by a specific version of a *component*.

To see a more detailed view of which *variant* Gradle resolved for a given configuration, you can run the `dependencyInsight` task:

[source,text]
----
$ ./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency com.google.guava:guava:33.0.0-jre

> Task :app:dependencyInsight

com.google.guava:guava:33.0.0-jre
  Variant jreRuntimeElements:
    | Attribute Name                 | Provided     | Requested    |
    |--------------------------------|--------------|--------------|
    | org.gradle.status              | release      |              |
    | org.gradle.category            | library      | library      |
    | org.gradle.dependency.bundling | external     | external     |
    | org.gradle.jvm.environment     | standard-jvm | standard-jvm |
    | org.gradle.jvm.version         | 8            | 11           |
    | org.gradle.libraryelements     | jar          | jar          |
    | org.gradle.usage               | java-runtime | java-runtime |

com.google.guava:guava:33.0.0-jre
\--- runtimeClasspath
----

In this example, Gradle uses the `jreRuntimeElements` variant* of `guava` for the `runtimeClasspath` configuration.

== 2. Artifact Resolution

**Artifact resolution** occurs after the dependency graph is constructed.
For each node in the dependency graph, Gradle fetches the necessary physical files (*artifacts*).

This process uses the resolved graph and repository definitions to produce the required files as output.

=== 1. Fetching artifacts

Gradle locates and downloads the actual artifacts (such as JAR files, ZIP files, etc.) referenced in the graph.
These artifacts correspond to the nodes discovered during graph resolution.

In our example, Gradle resolved the `jreRuntimeElements` variant of `com.google.guava:guava:33.0.0-jre` during the dependency graph resolution.
The artifact resolution phase retrieves the corresponding JAR file (`guava-33.0.0-jre.jar`) and its transitive dependencies, like `jsr305` or `failureaccess`, from the specified repositories.

=== 2. Artifact resolution rules

If any artifact resolution rules are defined in the build script, they are applied at this stage.
These rules might involve substituting one artifact for another:

[source,kotlin]
----
configurations {
    runtimeClasspath {
        resolutionStrategy {
            dependencySubstitution {
                // Substitutes the module com.google.guava:guava:33.0.0-jre with com.google.guava:guava-light:33.0.0-jre, targeting runtime resolution.
                substitute(module("com.google.guava:guava:33.0.0-jre")).with(module("com.google.guava:guava-light:33.0.0-jre"))
            }
        }

        // View the incoming resolved artifacts
        incoming.artifactView {
            attributes {
                // Set an artifactType of "jar" to only consider JAR files.
                attribute(Attribute.of("artifactType", String::class.java), "jar")
            }

            artifacts {
                // Prints the resolved artifact, guava-light:33.0.0-jre instead of guava:33.0.0-jre.
                eachArtifact { artifact ->
                    println("Resolved artifact: ${artifact.file.name}")
                }
            }
        }
    }
}
----

[.text-right]
**Next Step:** <<variant_aware_resolution.adoc#variant_aware_resolution,View Variant-Aware Dependency Resolution in Action>> >>
